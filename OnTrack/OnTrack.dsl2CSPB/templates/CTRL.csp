{-
 Date: $date
 Notes:  CSP Controller for $model model with 2 trains
 
 Generated by: Automatically produced by Version $version of OnTrack tool
 Authors of Tool: Hoang Nga Nguyen, Philip James
 Authors of Model: Moller, Nguyen, Roggenbach, Schneider, Treharne
 Corresponding Authors: Hoang Nga Nguyen, Philip James
 
 Description: 
 A CSP process to guide the Interlocking.mch

 First open the Interlocking.mch file as usual in ProB
 Then select the menu item
        Menu -> File -> Open Special -> Use CSP File to Guide B
 You have to be in normal mode to see this menu item (not in beginner mode)

 Comments: This model describes the train behaviour of an open system with trains exiting and remaining on the exit track. 
-}
[%
var cspScript1 : CSP!CSPScript;
cspScript1 := CSP!CSPScript.all().at(0);
%]

-- datatype definitions corresponding to those given in the Context.mch
datatype TRAIN = Hugo | Erna
datatype ASPECT = red | green | nosignal
datatype ANSWER = yes | no

-- following datatypes are generated: POS, ALLROUTE
[%
for (dt in cspScript1.dataType)
{
	if( dt.isDefined() ) --  and not(dt.name.isNativeCSPType())) 
	{
		out.println( dt.write(0) );
		--out.println();
	}
}
%]
-- end generating datatypes

--following sets are generated: BUFFER, ROUTE, SIGNALHOME
[%
for (st in cspScript1.set)
{
	out.println( st.write(0) );
}
%]
-- end generating sets

ALLTRACK = POS
TRACK = ALLTRACK

-- the rest of this file is the same for all track plans
-- define channels with names that correspond to the B operations in the Interlocking.mch
channel enter: TRAIN.ALLTRACK.ANSWER
channel exit: TRAIN.ALLTRACK.ANSWER
channel nextSignal : TRAIN.ALLTRACK.ASPECT
channel move : TRAIN.ALLTRACK.ALLTRACK
channel request : ROUTE.ANSWER
channel release : ROUTE.ANSWER
channel hiddenRequest : HIDDENROUTE.ANSWER
channel changeDirection: TRAIN.ALLTRACK
--definition of error channels
channel collide,derail,runThrough


--controller process to deal with route requests and releasing of routes
RW_CTRL =
  ([] r : ROUTE @ request!r?ans -> RW_CTRL)
  []
  ([] r : ROUTE @ release!r?ans -> RW_CTRL)
  []
  ([] r : HIDDENROUTE @ hiddenRequest!r?ans -> RW_CTRL)

--definition of individual train control process
TRAIN_OFF(t) = move!t!offUnit?np -> TRAIN_CTRL(t,np,false)

--process to determine movement of train, trains do not move through red signals
TRAIN_CTRL(t,pos,u_turned) =
if pos==offUnit then TRAIN_OFF(t) else
if pos==nullUnit then STOP else
(
  if member(pos,BUFFER) and not(u_turned) then 
    changeDirection.t.pos -> TRAIN_CTRL(t,pos,true) 
  else
  if member(pos,SIGNALHOME) then
    nextSignal!t!pos?aspect ->
      if aspect==green or aspect==nosignal then
        (move.t.pos?newp -> TRAIN_CTRL(t,newp,false))
      else -- aspect==red
        (TRAIN_CTRL(t,pos,u_turned))
  else
    (move.t.pos?newp -> TRAIN_CTRL(t,newp,false))
)

--definition of all train processes which are not initially on the tracks
ALL_TRAINS = ||| t : TRAIN @ TRAIN_OFF(t)

--definitons to model collision and derailment and runthrough
--these processes serve no purpose in the CSP but are included so that the alphabets of the CSP and B match
--they are events that are used in the CTL model checking
ErrorEvent = {collide,derail,runThrough}
ERROR = [] error : ErrorEvent @ error -> ERROR

--define the composition of the route controller, all trains and the error events
--control the entry of the two trains in the model to limit the state space
CTRL_WITH_TRAINS = RW_CTRL ||| ALL_TRAINS

-- Main process which enables the B and CSP to be analysed together
-- is needed in order to run through ProB
MAIN = CTRL_WITH_TRAINS ||| ERROR

[%

@cached
operation Integer indent() : String {
	var indentation : String := '';
	var i: Integer := 0;
	while(i < self) {
		indentation := indentation + '';
		i := i + 1;
	}
	return indentation;
}

operation DatatypeItemList write(i : Integer) : String 
{
	var indt : String := i.indent();
	var toReturn : String := '';
	
	if(self.size > 0) 
	{
		var ppli : DatatypeItem := self.firstItem;
		toReturn := indt;
		var sep : String := '';
		
		while(ppli.isDefined()) 
		{
			toReturn := toReturn + sep + ppli.name;
			ppli := ppli.preceeds;
			sep := ' | ';
			--ppli.name.println('<><><><<><><><><><>');
		}

	}
	return toReturn;
}

operation Datatype write(i : Integer) : String 
{
	var indt : String := i.indent();
	var nm : String := '';
	
	if(self.typeName.isDefined() and self.itemList.isDefined()) 
	{
			nm := indt + 'datatype ' + self.typeName + ' = ' + self.itemList.write(i + 1);
	}
		
	return nm;
}


operation SET write(i : Integer) : String 
{
	var toReturn : String;
	if(not(self.name = '')) 
	{
		var indt : String := i.indent();
		toReturn:= indt+self.name+' = '+(i+1).indent() + '{ ';
		var sep : String := '';
		
		for(el in self.item) 
		{
			if(el.item.isDefined()) -- mutually exclusive: either is a typeditem or event 
			{ 
				toReturn := toReturn + sep + el.item.name ;
			} 
			else 
			{
				toReturn := toReturn + sep + el.event.writeEvent(true);
			}
			sep := ', ';
		}
		
		toReturn := toReturn + ' }';
	}
	else 
	{
		toReturn := '';
	}
	return toReturn;
}

%]
