{-
 Date: $date
 Notes:  CSP model with 2 trains

 Generated by: Automatically produced by Version $version of OnTrack tool
 Authors of Tool: Hoang Nga Nguyen, Philip James
 Authors of Model: Xu, Moller, Nguyen, Roggenbach
 Corresponding Authors: Xu, Hoang Nga Nguyen, Philip James

 Description:
 Complete CSP model of the railway interlocking

 Open in FDR3.

 -}
[%
var cspScript1 : CSP!CSPScript;
cspScript1 := CSP!CSPScript.all().at(0);
%]

-- following datatypes are generated: UnitID, PointID, SignalID, RouteID
[%
for (dt in cspScript1.dataType)
{
	if( dt.isDefined() ) --  and not(dt.name.isNativeCSPType()))
	{
		out.println( dt.write(0) );
		--out.println();
	}
}
%]
-- end generating datatypes

--following sets are generated: PortID, BiDirPointTC, UniDirPointTC, BiDirLineTC, UniDirLineTC, CrossingID, BiPointConfig,
--                              BiLineConfig, CrossingConfig, EntryRoute,
[%
for (st in cspScript1.set)
{
  if (st.name == "") continue;
	out.println( st.write() );
}
%]
-- end generating sets

[%
for (fn in cspScript1.process)
{
	out.println( fn.write() );
}
%]

-- following functions are generated: pointAt, signalAt, routeOpenBy, routeCloseBy, entryUsedBy, ctrlTable,
--                                    releaseTable

-------------------------following are generic for all models
datatype PointST = Norm | Rvers   --***********************************

swap(Norm)=Rvers
swap(Rvers)=Norm

BiLineDir    = {(t0,t,t1), (t1,t,t0)              --***********************************
                 | (t,t0,t1) <- BiLineConfig}   --***********************************


CrossingDir  = {(t0,t,t1), (t1,t,t0), (t2,t,t3), (t3,t,t2)  --***********************************
                 | (t,(t0,t1),(t2,t3)) <- CrossingConfig}  --***********************************



-- offtrack is reached one later than in the original models of the group
BiPointDir    = {(m,t,n), (n,t,m), (m,t,r), (r,t,m),  --***********************************
                 (n,t,OFFTRACK), (r,t,OFFTRACK)       --***********************************
                 | (t,m,n,r) <- BiPointConfig}        --***********************************


ConfigDir = Union({BiPointDir, UniLineConfig, BiLineDir,CrossingDir})


OkDir = diff(ConfigDir, BannedDir)   --***********************************


pointDir(pID, Norm)=  diff({(m,t,n), (n,t,m), (r,t,OFFTRACK) | (t,m,n,r) <- BiPointConfig, t==pointAt(pID)}, BannedDir)

pointDir(pID, Rvers)= diff({(m,t,r), (r,t,m), (n,t,OFFTRACK) | (t,m,n,r) <- BiPointConfig, t==pointAt(pID)}, BannedDir)




--next(entryConnector)=exitConnector
next(n, t) = { x | x <- UnitID, member((n,t,x), OkDir)}   --***********************************


--Entry and Exit sets
EntrySet = { (n, t) | (n, t, x) <- OkDir, member(n, PortID) }

ExitSet =  { (t, x) | (n, t, x) <- OkDir, member(x, PortID) }

entrySignal(r) = { sID | sID <- SignalID, member(r,routeOpenBy(sID)) }

exitSignal(r)  = { sID | sID <- SignalID, member(r,routeCloseBy(sID)) }

clearTable(route)   = let
                        (_,_,clearTracks) = ctrlTable(route)
                      within
                        clearTracks


NormalPoints(route) =  let
      (points,_,_) = ctrlTable(route)
                      within
                        points

ReversePoints(route) =  let
      (_,points,_) = ctrlTable(route)
                      within
                        points

pointRoute(pID,st) = {r | r <- RouteID, member(pID, if st==Norm then NormalPoints(r) else ReversePoints(r))}

pointAllRoute(pID) = {r | r <- RouteID, member(pID, union(ReversePoints(r),NormalPoints(r)))}

pointInRoute(pID)  = {r | r <- pointAllRoute(pID), member(pointAt(pID), clearTable(r))}
-- route in which the point is non-flank protection -----

ReleaseMove(pID,rID)     = {move.cp.np | (r,cp,np) <- releaseTable(pID), r==rID}
PointReleaseMove(pID) = {move.cp.np | (r,cp,np) <- releaseTable(pID)}
--PointReleaseMove(pID,st) = {move.cp.np | rID <- pointRoute(pID,st), (r,cp,np) <- releaseTable(pID), r==rID}

----------------------------------------------------------------------------
pick({r})=r

TrainID = {1,2}

--Types/Channels
channel move: UnitID.UnitID --Train Movement
channel setRoute: RouteID --Route being Set
channel cancelRoute: RouteID -- Route being cancelled
channel switch: PointID -- Point direction being changed
channel hangMove: UnitID.UnitID  -- Hang Signal
channel turnAround: UnitID.UnitID.UnitID  -- Train change direction
channel pullover: UnitID.UnitID  -- Train pulls over
channel derail : PointID -- demonstrates a derailment has occured
channel perror : PointID  -- demonstrates a point error has occured
channel serror : SignalID -- demonstrates a signal error has occured


-- alphabet of train: i.e. {|setRoute,cancelRoute,move,hangMove,pullover,turnAround|}

TrainBehave(id,en,tk) = (move.en.tk -> if empty(next(en,tk)) 
                                            then [] (en1,tk1): EntrySet @ TrainBehave(id,en1,tk1)   
                                         -- then TrainStop(id,OFFTRACK)
                                            else [] nt: next(en,tk) @ TrainBehave(id,tk,nt))
        		[]
        		([] r: RouteID @ not(member(en,clearTable(r))) & setRoute.r -> TrainBehave(id,en,tk))
        		[]
        		([] r: RouteID @ if empty(entrySignal(r)) then cancelRoute.r -> TrainBehave(id,en,tk)
                                         else [] sID : entrySignal(r) @ (en,tk)!=signalAt(sID) & 
                                                       cancelRoute.r -> TrainBehave(id,en,tk))
                         --Required to check a train is not about to enter a route it will cancel.
        		[]
        		([] sID : SignalID @ (en,tk)==signalAt(sID) & hangMove.en.tk -> STOP 
                                                                                     --TrainStop(id,tk)
                        )
        		[]
        		([] sID : SignalID @ (en,tk)==signalAt(sID) & pullover.en.tk ->
                               ([] nt: next(tk,en) @ [] rsID: SignalID @ signalAt(rsID)==(en,nt) & 
                                                             turnAround.en.tk.nt -> TrainBehave(id,en,nt))
                        )


TrainStop(id,en)      = ([] r: RouteID @ not(member(en,clearTable(r))) & setRoute.r -> TrainStop(id,en))
        		[]
        		([] r: RouteID @ cancelRoute.r -> TrainStop(id,en))


Trains = [|{|setRoute,cancelRoute|}|] id: TrainID @ ([] (en,tk): EntrySet @ TrainBehave(id,en,tk))

EntryGuard = [] r: EntryRoute @ (setRoute.r -> let (en,tk)=entryUsedBy(r) within
                                   ( move.en.tk -> EntryGuard [] cancelRoute.r -> EntryGuard ) )

EntryAlphMove  = { move.en.tk | (en,tk) <- EntrySet }
EntryAlphRoute = {setRoute.r,cancelRoute.r | r <- EntryRoute}

GuardedTrains =  Trains [|union(EntryAlphMove, EntryAlphRoute)|] EntryGuard


datatype Aspect = Red | Green


routeRversGuardBy(sID)=
    let (en,tk) = signalAt(sID) within
       diff({r | r <- RouteID, member(tk,top(r))}, union(routeOpenBy(sID),routeCloseBy(sID)))


MaxDupLock=card(TrainID)+1

SignalBehave(sID, st, lk)=
    let (en,tk) = signalAt(sID) within               
         ([] r: routeOpenBy(sID) @ st==Green & cancelRoute.r -> SignalBehave(sID,Red,lk))
        []
         ([] r: routeOpenBy(sID) @ st==Red and lk==0 & setRoute.r -> SignalBehave(sID,Green,lk))
        []
         (st==Red & hangMove.en.tk -> SignalBehave(sID,st,lk))
        []
         (st==Red & pullover.en.tk -> SignalBehave(sID,st,lk))
        []
         (st == Green & move.en.tk -> SignalBehave(sID,Red,lk))
        []   ----------begin{receptive} 
         (lk == 0 & move.tk.en -> serror.sID -> STOP)
        []
         (lk != 0 & move.tk.en -> SignalBehave(sID,st,lk-1))
        []
         ([] r: routeRversGuardBy(sID) @ lk!=0 & cancelRoute.r -> SignalBehave(sID,st,lk-1))
        []
         ([] r: routeRversGuardBy(sID) @ lk==0 & cancelRoute.r -> serror.sID -> STOP)
        []
         ([] r: routeCloseBy(sID)  @ cancelRoute.r -> SignalBehave(sID,st,lk))
        []   ----------end{receptive}
         ([] r: routeRversGuardBy(sID) @ st==Red and lk < MaxDupLock & setRoute.r -> SignalBehave(sID,st,lk+1))
        []
         ([] r: routeCloseBy(sID)  @ lk==0 & setRoute.r -> SignalBehave(sID,st,lk))
                                                      



sigAlphRoute(sID) =  { cancelRoute.r, setRoute.r | 
       r <- Union({routeOpenBy(sID),routeRversGuardBy(sID),routeCloseBy(sID)}) }   

sigAlphMove(sID) = let (en,tk) = signalAt(sID) within { move.en.tk, move.tk.en}

sigAlphOther(sID) =  let (en,tk) = signalAt(sID) within {hangMove.en.tk, pullover.en.tk, serror.sID}

Signals = || sID: SignalID @ [ Union({sigAlphRoute(sID), sigAlphMove(sID), sigAlphOther(sID)})] SignalBehave(sID, Red, 0)


sigSysAlphMove  = Union({sigAlphMove(sID) | sID <- SignalID})

sigSysAlphRoute = Union({sigAlphRoute(sID) | sID <- SignalID}) -- == {| setroute, cancelroute |}


unlock(mv,pID)={r | r <- RouteID, member(mv,ReleaseMove(pID,r))}

PointExitMove(pID) = { move.tk.ex | (en, tk, ex) <- OkDir, pointAt(pID)==tk }              --***********************************


PointEntry(pID,st)=    
        (switch.pID -> PointEntry(pID,swap(st)))
     [] ([] (en,tk,ex): pointDir(pID, st) @
           move.en.tk ->(let ActivePoint =
                             (ex==OFFTRACK & move.tk.ex -> STOP)
                          [] (ex!=OFFTRACK & move.tk.ex -> PointEntry(pID,st))
                          [] (switch.pID -> derail.pID -> STOP)
                          [] ([] (en',tk',ex'): pointDir(pID, st) @ move.en'.tk' -> STOP)
                          [] ([] r : pointRoute(pID,st) @ setRoute.r -> ActivePoint)
                          [] ([] r : pointRoute(pID,st) @ cancelRoute.r -> ActivePoint)
                         within ActivePoint 
                        )
        )
     [] ([] r : pointRoute(pID,st) @ setRoute.r -> PointEntry(pID,st))
     [] ([] r : pointRoute(pID,st) @ cancelRoute.r -> PointEntry(pID,st))


pntEnAlphMove(pID) = { move.en.tk, move.tk.ex | st <- PointST, (en,tk,ex) <- pointDir(pID, st) }

pntAlphRoute(pID) = { setRoute.r, cancelRoute.r | r <- pointAllRoute(pID) } 


num(lm,r)  = if mapMember(lm,r) then mapLookup(lm,r) else 0

--let N = { n | (r',n) <- lm, r'==r } within if N=={} then 0 else pick(N)

plus(lm,r)  = mapUpdate(lm,r, num(lm,r)+1)

--num(lm,r)==0 then union(lm, (r,1)) else union(diff(lm, (r, num(lm,r))), (r, num(lm,r)+1))

--Plus(lm,R) = Union({plus(lm,r) | r <- R)

minus(lm,r) = if num(lm,r)==0 then lm else if num(lm,r)==1 then mapDelete(lm,r) else mapUpdate(lm,r, num(lm,r)-1)

--union(diff(lm, (r, num(lm,r))), (r, num(lm,r)-1))

--Minus(lm,R) = Inter(minus(lm,r) | r <- R)

PointExit(pID,toCancel,toRelease)=
      (toCancel == emptyMap and toRelease == emptyMap & switch.pID -> PointExit(pID,emptyMap,emptyMap))
------begin{receptive}
   [] ([]r: pointAllRoute(pID)@ setRoute.r -> if member(r, pointInRoute(pID)) 
                                              then if ( toCancel == emptyMap or toCancel == (| r => num(toCancel,r) |) ) and num(toCancel,r) <= MaxDupLock
                                                   then PointExit(pID, plus(toCancel,r), toRelease)
                                                   else perror.pID -> STOP 
                                              else if num(toRelease,r) <= MaxDupLock 
                                                   then PointExit(pID, toCancel, plus(toRelease,r))
                                                   else perror.pID -> STOP)
   [] ([]r: pointAllRoute(pID)@ cancelRoute.r -> if num(toCancel,r) != 0 or num(toRelease,r) != 0 
                                                 then PointExit(pID, minus(toCancel,r), minus(toRelease,r)) 
                                                 else perror.pID -> STOP)
   [] ([] mv : PointExitMove(pID) @ mv -> 
          let unlk= { r | r <- unlock(mv,pID), num(toCancel,r) != 0 or num(toRelease,r) != 0 } within
            if toCancel==emptyMap then perror.pID -> STOP
            else if empty(unlk) then PointExit(pID, toCancel, toRelease)
                 else if card(unlk)==1 and num(toCancel,pick(unlk))!=0  then PointExit(pID, minus(toCancel,pick(unlk)), toRelease)
                      else perror.pID -> STOP)
   [] ([] mv : diff(PointReleaseMove(pID),PointExitMove(pID)) @ mv -> 
          let unlk= { r | r <- unlock(mv,pID), num(toCancel,r) != 0 or num(toRelease,r) != 0 } within
            if empty(unlk) then PointExit(pID, toCancel, toRelease)
            else if card(unlk)==1
                 then PointExit(pID, minus(toCancel,pick(unlk)), minus(toRelease,pick(unlk)))
                 else perror.pID -> STOP)
------end{receptive}

pntExAlphMove(pID) = union(PointReleaseMove(pID), PointExitMove(pID))


PointBehave(pID) =  PointEntry(pID, Norm) [ Union({pntAlphRoute(pID), pntEnAlphMove(pID), {switch.pID, derail.pID}}) 
                                     || Union({pntAlphRoute(pID), pntExAlphMove(pID), {switch.pID,perror.pID}}) ] PointExit(pID, emptyMap, emptyMap)

pntAlphMove(pID) = union(pntEnAlphMove(pID), pntExAlphMove(pID)) 


Points =  || pID:PointID @ [ Union({pntAlphRoute(pID), pntAlphMove(pID), {switch.pID, derail.pID, perror.pID}}) ] PointBehave(pID) 

pntSysAlphMove  = Union({pntAlphMove(pID) | pID <- PointID})

pntSysAlphRoute = Union({pntAlphRoute(pID) | pID <- PointID})

-- and {| switch, derail, perror |}



TrackSystem = Points [| union(pntSysAlphRoute,inter(sigSysAlphMove,pntSysAlphMove)) |] Signals

trackSysAlphMove = union(sigSysAlphMove,pntSysAlphMove)

trackSysAlphRoute = union(sigSysAlphRoute, pntSysAlphRoute)


FullSystem = TrackSystem [| Union({trackSysAlphMove,trackSysAlphRoute, {|hangMove,pullover|}}) |] GuardedTrains







$safetychecks
-- NoLocalCollision= move?en!focustrack -> move!focustrack?ex -> NoLocalCollision
-- assert NoLocalCollision [T= FullSystem \ union({| setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror, turnAround|}, {move.en.ex | en <- UnitID, ex <- UnitID, en!=focustrack and ex!=focustrack})


--No Collision
NoCol(en,tk,en',tk')= (tk != en' or member(tk,PortID) & move.en.tk -> if empty(next(en,tk)) 
                                                   then [](en1,tk1): EntrySet @ NoCol(en1,tk1,en',tk')
                                                   else [] nt: next(en,tk) @ NoCol(tk,nt,en',tk'))
                     [] (tk' != en  or member(en,PortID) & move.en'.tk' -> 
                                                     if empty(next(en',tk')) 
                                                     then [](en2,tk2): EntrySet @ NoCol(en,tk,en2,tk2)
                                                     else []nt': next(en',tk') @ NoCol(en,tk,tk',nt'))
                     [] ([] nt: next(tk,en) @ turnAround.en.tk.nt -> NoCol(en,nt,en',tk'))
                     [] ([] nt': next(tk',en') @ turnAround.en'.tk'.nt' -> NoCol(en,tk,en',nt'))



NoCollisionViolation = [](en,tk): EntrySet @ [] (en',tk'): EntrySet @ NoCol(en,tk,en',tk') 


assert NoCollisionViolation [T= FullSystem \ {| setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror |}


--No Run Through

NonRunthroughMove =  { move.en.tk | en <- UnitID, tk <- UnitID, tk!=OFFTRACK }

assert  CHAOS(NonRunthroughMove) [T= FullSystem \ {|turnAround, setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror|}


--No Derailment Property

assert  CHAOS({|setRoute,cancelRoute,move,hangMove,pullover,switch,perror,serror|}) [T= FullSystem \ {|turnAround|}


--No Error

assert  CHAOS({|setRoute,cancelRoute,switch,derail|}) [T= FullSystem \ {|move,hangMove,pullover,turnAround|}








-------------- model end here ------------
[%

@cached
operation Integer indent() : String {
	var indentation : String := '';
	var i: Integer := 0;
	while(i < self) {
		indentation := indentation + '';
		i := i + 1;
	}
	return indentation;
}

operation DatatypeItemList write(i : Integer) : String
{
	var indt : String := i.indent();
	var toReturn : String := '';

	if(self.size > 0)
	{
		var ppli : DatatypeItem := self.firstItem;
		toReturn := indt;
		var sep : String := '';

		while(ppli.isDefined())
		{
			toReturn := toReturn + sep + ppli.name;
			ppli := ppli.preceeds;
			sep := ' | ';
			--ppli.name.println('<><><><<><><><><><>');
		}

	}
	return toReturn;
}

operation Datatype write(i : Integer) : String
{
	var indt : String := i.indent();
	var nm : String := '';

	if(self.typeName.isDefined() and self.items.size() > 0)
	{
		nm := indt + 'datatype ' + self.typeName + ' = ';
		var first = true;
	  for(t in self.items) {
			if (not first) nm := nm + " | ";
			else first = false;
		  nm := nm + t.name;
		}
	}

	return nm;
}

operation OrderedSet write() : String {
	var ret := "(";
  var first  = true;
	for(i in self) {
    if (not first) { ret := ret + ", "; first := false;}
		else {first := false;}
    ret := ret + i.write();
	}
  return ret + ")";
}

operation TypedItem write() : String {
  return self.name;
}

operation SET write() : String
{
	var toReturn : String;
	if(not(self.name = ''))	toReturn:= self.name+' = ';

	toReturn := toReturn + '{ ';
	var sep : String := '';

	for(el in self.item)
	{
		if(el.item.isDefined()) -- mutually exclusive: either is a typeditem or event
		{
			toReturn := toReturn + sep + el.item.write() ;
		}
		else
		{
			toReturn := toReturn + sep + el.event.writeEvent(true);
		}
		sep := ', ';
	}

	toReturn := toReturn + ' }';

	return toReturn;
}

operation ProcessParameterList write() : String {
	var ret := "(";
  var sep := "";
	for(p in self.item) {
		ret := ret + sep + p.write();
	  sep := ", ";
	}
	return ret + ")";
}

operation ProcessID write() : String {
	var ret := self.name;
	if (self.parameterList.isDefined()) {
		ret := ret + self.parameterList.write();
	}
  return ret;
}

operation ProcessAssignment write() : String
{
	var ret := "p=e";
	ret := self.processID.write() + " = " + self.processExpression.write();
	return ret;
}


%]
