NoCollisionTrack(id) = UnoccupiedTrack(id)
UnoccupiedTrack(id) =
  (move?t1.id -> OccupiedTrack(id))
  []
  (hangMove?t1.id -> OccupiedTrack(id))

OccupiedTrack(id) =
  (move.id?t2 -> UnoccupiedTrack(id))
  []
  (hangMove.id?t2 -> UnoccupiedTrack(id))

NoCollisionTrackAlpha(id) = union({move.t1.id, hangMove.t1.id | t1 <- TrackID},{|move.id, hangMove.id|})

NoCollision = OccupiedTrack2(OFFTRACK,OFFTRACK)
NoCollisionAlpha = {|move|}

OccupiedTrack2(t1,t2) =
([] t : FreeTracks(t1,t2), m : {move.t1.t,hangMove.t1.t} @ m -> OccupiedTrack2(t,t2))
[]
([] t : FreeTracks(t2,t1), m : {move.t2.t,hangMove.t2.t} @ m -> OccupiedTrack2(t1,t))

FreeTracks(t1,t2) = diff(union(diff(TrackID,{t2}),{OFFTRACK}),{t1})

NoDerailmentPoint(id) = UnoccupiedPoint(id)

UnoccupiedPoint(id) =
  (switch.id -> UnoccupiedPoint(id))
  []
  (let Tid = pointAt(id) within
    (move?t1.Tid -> OccupiedPoint(id))
    []
    (hangMove?t1.Tid -> OccupiedPoint(id))
  )

OccupiedPoint(id) =
  (move.pointAt(id)?t2 -> UnoccupiedPoint(id))
  []
  (hangMove.pointAt(id)?t2 -> UnoccupiedPoint(id))

NoDerailmentPointAlpha(id) = union({move.t1.pointAt(id), hangMove.t1.pointAt(id) | t1 <- TrackID},{|move.pointAt(id),hangMove.pointAt(id),switch.id|})

NoDerailment = || id : { p | p <- PointID , member(pointAt(p),Critical) } @ [NoDerailmentPointAlpha(id)] NoDerailmentPoint(id)
NoDerailmentAlpha = Union({NoDerailmentPointAlpha(id) | id <- PointID, member(pointAt(id),Critical)})


NoRunThruPoint(id) = NoRunThruNormal(id)
NoRunThruNormal(id) =
  (move.normalNext(id).pointAt(id) -> NoRunThruNormal(id))
  []
  (hangMove.normalNext(id).pointAt(id) -> NoRunThruNormal(id))
  []
  (switch.id -> NoRunThruReverse(id))
NoRunThruReverse(id) =
  (hangMove.reverseNext(id).pointAt(id) -> NoRunThruReverse(id))
  []
  (move.reverseNext(id).pointAt(id) -> NoRunThruReverse(id))
  []
  (switch.id -> NoRunThruNormal(id))
NoRunThruPointAlpha(id) = {move.normalNext(id).pointAt(id),hangMove.normalNext(id).pointAt(id),move.reverseNext(id).pointAt(id),hangMove.reverseNext(id).pointAt(id),switch.id}

NoRunThru = || id : { p | p <- PointID , member(pointAt(p),Critical) } @ [NoRunThruPointAlpha(id)] NoRunThruPoint(id)
NoRunThruAlpha = Union({NoRunThruPointAlpha(id) | id <- PointID, member(pointAt(id),Critical)})
