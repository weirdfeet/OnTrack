MACHINE Topology

/* Date: Tue Sep 13 11:34:48 BST 2016
 * Notes: supporting platform:/resource/Trackplans/default.ontrack model
 * Automatically generated by TrackScheme2CSPB tool version 0.2
 * Authors of Tool: Hoang Nga Nguyen, Philip James
 * Authors: Moller, Nguyen, Roggenbach, Schneider, Treharne
 *  Corresponding Authors: Hoang Nga Nguyen and Philip James
 */


SEES  Context

/*

signal: the signal associated with a route
homeSignal: the track where the signal is situated
homePoints: the track where the points are situated
next: the relation between tracks and possible successor tracks
staticNext: the successors of tracks which are independent of point positions
dynamicNext: the successors of tracks which are dependent on point positions and the dependency is included in the function

Note: if tracks go in different directions then homeSignal need not be injective
*/
/* egl */
CONSTANTS
    ENTRY, EXIT, TERMINAL, CROSSING,
    signal, homeSignal, homePoint,
    directedUnits, staticDirection, dynamicDirection,
    topoRoute, staticNext, topoRouteTable

PROPERTIES
    signal : ROUTE --> SIGNAL &
    homeSignal : SIGNAL >-> UNIT * (CONNECTOR*CONNECTOR) &
    homePoint : POINT --> UNIT &
    CROSSING <: UNIT &
    ran(homePoint) /\ CROSSING  = {} &
    ENTRY <: directedUnits &
    EXIT  <: directedUnits &
    TERMINAL <: UNIT &
    dom(ENTRY) /\ TERMINAL = {} &
    dom(EXIT)  /\ TERMINAL = {} &
    directedUnits : UNIT <-> CONNECTOR * CONNECTOR &
    staticNext : directedUnits +-> UNIT &
    staticNext =
    { dU |-> n | #(t,d1,d2).(dU = (t,d1) &
                            t /= n &
                            ran({d1}) = dom({d2}) &
                            dU : directedUnits &
                            (n,d2) : directedUnits) } &
    staticDirection : CONNECTOR <-> CONNECTOR &
    staticDirection = ran((UNIT - (ran(homePoint) \/ {nullUnit})) <| directedUnits) &

    dynamicDirection : POINT * POINTPOSITION <-> CONNECTOR * CONNECTOR &
    topoRouteTable : ROUTE * UNIT <-> CONNECTOR * CONNECTOR &
    topoRoute : ROUTE <-> directedUnits &
    topoRoute = { r |-> dU | #(t,d).(dU = (t,d) & d : topoRouteTable[{(r,t)}]) } &

    signal = {(R2) |-> (S2), (R1) |-> (S1), (R1B) |-> (S1)} &
    homeSignal = {(S1) |-> (AA,(1,(3))), (S2) |-> (AC,(5,(7)))} &
    homePoint = {(P1) |-> (AB)} &
    CROSSING = {} &
    ENTRY = {(AA) |-> (1,(3))} &
    EXIT = {(AE) |-> (9,(10)), (AB) |-> (3,(2))} &
    TERMINAL = {} &
    directedUnits = {(nullUnit) |-> (-1,(-1)), (offUnit) |-> (0,(0)), (AA) |-> (1,(3)), (AA) |-> (3,(1)), (AB) |-> (3,(5)), (AB) |-> (5,(3)), (AC) |-> (5,(7)), (AC) |-> (7,(5)), (AD) |-> (7,(9)), (AD) |-> (9,(7)), (AE) |-> (9,(10)), (AE) |-> (10,(9)), (AB) |-> (3,(2)), (AB) |-> (2,(3))} &
    dynamicDirection = {(P1,(normal)) |-> (3,(5)), (P1,(normal)) |-> (5,(3)), (P1,(reverse)) |-> (3,(2)), (P1,(reverse)) |-> (2,(3))} &
    topoRouteTable = {(R2,(AC)) |-> (5,(7)), (R2,(AD)) |-> (7,(9)), (R2,(AE)) |-> (9,(10)), (R1B,(AA)) |-> (1,(3)), (R1B,(AB)) |-> (3,(2)), (R1,(AA)) |-> (1,(3)), (R1,(AB)) |-> (3,(5)), (R1,(AC)) |-> (5,(7))}

END

