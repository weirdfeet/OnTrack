{-
 Date: Tue Sep 13 10:39:33 BST 2016
 Notes:  CSP model with 2 trains

 Generated by: Automatically produced by Version 0.1 of OnTrack tool
 Authors of Tool: Hoang Nga Nguyen, Philip James
 Authors of Model: Xu, Moller, Nguyen, Roggenbach
 Corresponding Authors: Xu, Hoang Nga Nguyen, Philip James

 Description:
 Complete CSP model of the railway interlocking

 Open in FDR3.

 -}

-- following datatypes are generated: UnitID, PointID, SignalID, RouteID
datatype UnitID = OFFTRACK | AA | AB | AC | AD | AE



-- end generating datatypes

--following sets are generated: PortID, BiDirPointTC, UniDirPointTC, BiDirLineTC, UniDirLineTC, CrossingID, BiPointConfig,
--                              BiLineConfig, CrossingConfig, EntryRoute,
PortID = {  }
BiDirPointTC = {  }
UniDirPointTC = {  }
BiDirLineTC = { AA, AB, AC, AD, AE }
UniDirLineTC = {  }
CrossingID = {  }
BiPointConfig = {  }
UniLineConfig = {  }
BiLineConfig = {  }
CrossingConfig = {  }
BannedDir = {  }
EntryRoute = {  }
-- end generating sets

-- following functions are generated: pointAt, signalAt, routeOpenBy, routeCloseBy, entryUsedBy, ctrlTable,
--                                    releaseTable

-------------------------following are generic for all models
datatype PointST = Norm | Rvers   --***********************************

swap(Norm)=Rvers
swap(Rvers)=Norm

BannedDir = {}


BiLineDir    = {(t0,t,t1), (t1,t,t0)              --***********************************
                 | (t,t0,t1) <- BiLineConfig}   --***********************************


CrossingDir  = {(t0,t,t1), (t1,t,t0), (t2,t,t3), (t3,t,t2)  --***********************************
                 | (t,(t0,t1),(t2,t3)) <- CrossingConfig}  --***********************************



-- offtrack is reached one later than in the original models of the group
BiPointDir    = {(m,t,n), (n,t,m), (m,t,r), (r,t,m),  --***********************************
                 (n,t,OFFTRACK), (r,t,OFFTRACK)       --***********************************
                 | (t,m,n,r) <- BiPointConfig}        --***********************************


ConfigDir = Union({BiPointDir, UniLineConfig, BiLineDir,CrossingDir})


OkDir = diff(ConfigDir, BannedDir)   --***********************************


pointDir(pID, Norm)=  diff({(m,t,n), (n,t,m), (r,t,OFFTRACK) | (t,m,n,r) <- BiPointConfig, t==pointAt(pID)}, BannedDir)

pointDir(pID, Rvers)= diff({(m,t,r), (r,t,m), (n,t,OFFTRACK) | (t,m,n,r) <- BiPointConfig, t==pointAt(pID)}, BannedDir)




--next(entryConnector)=exitConnector
next(n, t) = { x | x <- UnitID, member((n,t,x), OkDir)}   --***********************************


--Entry and Exit sets
EntrySet = { (n, t) | (n, t, x) <- OkDir, member(n, PortID) }

ExitSet =  { (t, x) | (n, t, x) <- OkDir, member(x, PortID) }

entrySignal(r) = { sID | sID <- SignalID, member(r,routeOpenBy(sID)) }

exitSignal(r)  = { sID | sID <- SignalID, member(r,routeCloseBy(sID)) }

clearTable(route)   = let
                        (_,_,clearTracks) = ctrlTable(route)
                      within
                        clearTracks


NormalPoints(route) =  let
      (points,_,_) = ctrlTable(route)
                      within
                        points

ReversePoints(route) =  let
      (_,points,_) = ctrlTable(route)
                      within
                        points

pointRoute(pID,st) = {r | r <- RouteID, member(pID, if st==Norm then NormalPoints(r) else ReversePoints(r))}

pointAllRoute(pID) = {r | r <- RouteID, member(pID, union(ReversePoints(r),NormalPoints(r)))}

pointInRoute(pID)  = {r | r <- pointAllRoute(pID), member(pointAt(pID), clearTable(r))}
-- route in which the point is non-flank protection -----

ReleaseMove(pID,rID)     = {move.cp.np | (r,cp,np) <- releaseTable(pID), r==rID}
PointReleaseMove(pID) = {move.cp.np | (r,cp,np) <- releaseTable(pID)}
--PointReleaseMove(pID,st) = {move.cp.np | rID <- pointRoute(pID,st), (r,cp,np) <- releaseTable(pID), r==rID}

----------------------------------------------------------------------------

TrainID = {1,2}

--Types/Channels
channel move: UnitID.UnitID --Train Movement
channel setRoute: RouteID --Route being Set
channel cancelRoute: RouteID -- Route being cancelled
channel switch: PointID -- Point direction being changed
channel hangMove: UnitID.UnitID  -- Hang Signal
channel turnAround: UnitID.UnitID.UnitID  -- Train change direction
channel pullover: UnitID.UnitID  -- Train pulls over
channel derail : PointID -- demonstrates a derailment has occured
channel perror : PointID  -- demonstrates a point error has occured
channel serror : SignalID -- demonstrates a signal error has occured


-- alphabet of train: i.e. {|setRoute,cancelRoute,move,hangMove,pullover,turnAround|}

TrainBehave(id,en,tk) = (move.en.tk -> if empty(next(en,tk))
                                            then [] (en1,tk1): EntrySet @ TrainBehave(id,en1,tk1)
                                         -- then TrainStop(id,OFFTRACK)
                                            else [] nt: next(en,tk) @ TrainBehave(id,tk,nt))
        		[]
        		([] r: RouteID @ not(member(en,clearTable(r))) & setRoute.r -> TrainBehave(id,en,tk))
        		[]
        		([] r: RouteID @ if empty(entrySignal(r)) then cancelRoute.r -> TrainBehave(id,en,tk)
                                         else [] sID : entrySignal(r) @ (en,tk)!=signalAt(sID) &
                                                       cancelRoute.r -> TrainBehave(id,en,tk))
                         --Required to check a train is not about to enter a route it will cancel.
        		[]
        		([] sID : SignalID @ (en,tk)==signalAt(sID) & hangMove.en.tk -> STOP
                                                                                     --TrainStop(id,tk)
                        )
        		[]
        		([] sID : SignalID @ (en,tk)==signalAt(sID) & pullover.en.tk ->
                               ([] nt: next(tk,en) @ [] rsID: SignalID @ signalAt(rsID)==(en,nt) &
                                                             turnAround.en.tk.nt -> TrainBehave(id,en,nt))
                        )


TrainStop(id,en)      = ([] r: RouteID @ not(member(en,clearTable(r))) & setRoute.r -> TrainStop(id,en))
        		[]
        		([] r: RouteID @ cancelRoute.r -> TrainStop(id,en))


Trains = [|{|setRoute,cancelRoute|}|] id: TrainID @ ([] (en,tk): EntrySet @ TrainBehave(id,en,tk))

EntryGuard = [] r: EntryRoute @ (setRoute.r -> let (en,tk)=entryUsedBy(r) within
                                   ( move.en.tk -> EntryGuard [] cancelRoute.r -> EntryGuard ) )

EntryAlphMove  = { move.en.tk | (en,tk) <- EntrySet }
EntryAlphRoute = {setRoute.r,cancelRoute.r | r <- EntryRoute}

GuardedTrains =  Trains [|union(EntryAlphMove, EntryAlphRoute)|] EntryGuard


datatype Aspect = Red | Green | Lock


routeRversGuardBy(sID)=
    let (en,tk) = signalAt(sID) within
       diff({r | r <- RouteID, member(en,clearTable(r))}, union(routeOpenBy(sID),routeCloseBy(sID)))

SignalBehave(sID, st)=
    let (en,tk) = signalAt(sID) within
         ([] r: routeOpenBy(sID) @ st==Green & cancelRoute.r -> SignalBehave(sID,Red))
        []
         ([] r: routeOpenBy(sID) @ st==Red  & setRoute.r -> SignalBehave(sID,Green))
        []
         (st==Red & hangMove.en.tk -> SignalBehave(sID,st))
        []
         (st==Red & pullover.en.tk -> SignalBehave(sID,st))
        []
         (st == Green & move.en.tk -> SignalBehave(sID,Red))
        []   ----------begin{receptive}
         (st != Lock & move.tk.en -> serror.sID -> STOP)
        []
         (st == Lock & move.tk.en -> SignalBehave(sID,Red))
        []
         ([] r: routeRversGuardBy(sID) @ st==Lock & cancelRoute.r -> SignalBehave(sID,Red))
        []
         ([] r: routeRversGuardBy(sID) @ st!=Lock & cancelRoute.r -> serror.sID -> STOP)
        []
         ([] r: routeCloseBy(sID)  @ cancelRoute.r -> SignalBehave(sID,st))
        []   ----------end{receptive}
         ([] r: routeRversGuardBy(sID) @ st==Red & setRoute.r -> SignalBehave(sID,Lock))
        []
         ([] r: routeCloseBy(sID)  @ st!=Lock & setRoute.r -> SignalBehave(sID,st))



sigAlphRoute(sID) =  { cancelRoute.r, setRoute.r |
       r <- Union({routeOpenBy(sID),routeRversGuardBy(sID),routeCloseBy(sID)}) }

sigAlphMove(sID) = let (en,tk) = signalAt(sID) within { move.en.tk, move.tk.en}

sigAlphOther(sID) =  let (en,tk) = signalAt(sID) within {hangMove.en.tk, pullover.en.tk, serror.sID}

Signals = || sID: SignalID @ [ Union({sigAlphRoute(sID), sigAlphMove(sID), sigAlphOther(sID)})] SignalBehave(sID, Red)


sigSysAlphMove  = Union({sigAlphMove(sID) | sID <- SignalID})

sigSysAlphRoute = Union({sigAlphRoute(sID) | sID <- SignalID}) -- == {| setroute, cancelroute |}


unlock(mv,pID)={r | r <- RouteID, member(mv,ReleaseMove(pID,r))}

PointExitMove(pID) = { move.tk.ex | (en, tk, ex) <- OkDir, pointAt(pID)==tk }              --***********************************


PointEntry(pID,st)=
        (switch.pID -> PointEntry(pID,swap(st)))
     [] ([] (en,tk,ex): pointDir(pID, st) @
           move.en.tk ->(let ActivePoint =
                             (ex==OFFTRACK & move.tk.ex -> STOP)
                          [] (ex!=OFFTRACK & move.tk.ex -> PointEntry(pID,st))
                          [] (switch.pID -> derail.pID -> STOP)
                          [] ([] (en',tk',ex'): pointDir(pID, st) @ move.en'.tk' -> STOP)
                          [] ([] r : pointRoute(pID,st) @ setRoute.r -> ActivePoint)
                          [] ([] r : pointRoute(pID,st) @ cancelRoute.r -> ActivePoint)
                         within ActivePoint
                        )
        )
     [] ([] r : pointRoute(pID,st) @ setRoute.r -> PointEntry(pID,st))
     [] ([] r : pointRoute(pID,st) @ cancelRoute.r -> PointEntry(pID,st))


pntEnAlphMove(pID) = { move.en.tk, move.tk.ex | st <- PointST, (en,tk,ex) <- pointDir(pID, st) }

pntAlphRoute(pID) = { setRoute.r, cancelRoute.r | r <- pointAllRoute(pID) }


PointExit(pID,toCancel,toRelease)=
      (toCancel == {} and toRelease == {} & switch.pID -> PointExit(pID,{},{}))
------begin{receptive}
   [] ([]r: pointAllRoute(pID)@ setRoute.r -> if member(r, pointInRoute(pID))
                                              then if toCancel=={}
                                                   then PointExit(pID, {r}, toRelease)
                                                   else perror.pID -> STOP
                                              else if member(r, toRelease)
                                                   then perror.pID -> STOP
                                                   else PointExit(pID, toCancel, union(toRelease,{r})))
   [] ([]r: pointAllRoute(pID)@ cancelRoute.r -> if member(r,union(toCancel,toRelease))
                                                 then PointExit(pID, diff(toCancel,{r}), diff(toRelease,{r}))
                                                 else perror.pID -> STOP)
   [] ([] mv : PointExitMove(pID) @ mv ->
          let unlk= inter(union(toCancel,toRelease),unlock(mv,pID)) within
            if empty(toCancel) then perror.pID -> STOP
            else if empty(unlk) then PointExit(pID, toCancel, toRelease)
                 else if unlk==toCancel then PointExit(pID, {}, toRelease)
                      else perror.pID -> STOP)
   [] ([] mv : diff(PointReleaseMove(pID),PointExitMove(pID)) @ mv ->
          let unlk= inter(union(toCancel,toRelease),unlock(mv,pID)) within
            if card(unlk)<=1
            then PointExit(pID, diff(toCancel,unlk), diff(toRelease,unlk))
            else perror.pID -> STOP)
------end{receptive}

pntExAlphMove(pID) = union(PointReleaseMove(pID), PointExitMove(pID))


PointBehave(pID) =  PointEntry(pID, Norm) [ Union({pntAlphRoute(pID), pntEnAlphMove(pID), {switch.pID, derail.pID}})
                                     || Union({pntAlphRoute(pID), pntExAlphMove(pID), {switch.pID,perror.pID}}) ] PointExit(pID, {}, {})

pntAlphMove(pID) = union(pntEnAlphMove(pID), pntExAlphMove(pID))


Points =  || pID:PointID @ [ Union({pntAlphRoute(pID), pntAlphMove(pID), {switch.pID, derail.pID, perror.pID}}) ] PointBehave(pID)

pntSysAlphMove  = Union({pntAlphMove(pID) | pID <- PointID})

pntSysAlphRoute = Union({pntAlphRoute(pID) | pID <- PointID})

-- and {| switch, derail, perror |}



TrackSystem = Points [| union(pntSysAlphRoute,inter(sigSysAlphMove,pntSysAlphMove)) |] Signals

trackSysAlphMove = union(sigSysAlphMove,pntSysAlphMove)

trackSysAlphRoute = union(sigSysAlphRoute, pntSysAlphRoute)


FullSystem = TrackSystem [| Union({trackSysAlphMove,trackSysAlphRoute, {|hangMove,pullover|}}) |] GuardedTrains








--No Collision
NoCol(en,tk,en',tk')= (tk != en' & move.en.tk -> if empty(next(en,tk))
                                                   then [](en1,tk1): EntrySet @ NoCol(en1,tk1,en',tk')
                                                   else [] nt: next(en,tk) @ NoCol(tk,nt,en',tk'))
                     [] (tk' != en & move.en'.tk' ->
                                                     if empty(next(en',tk'))
                                                     then [](en2,tk2): EntrySet @ NoCol(en,tk,en2,tk2)
                                                     else []nt': next(en',tk') @ NoCol(en,tk,tk',nt'))
                     [] ([] nt: next(tk,en) @ turnAround.en.tk.nt -> NoCol(en,nt,en',tk'))
                     [] ([] nt': next(tk',en') @ turnAround.en'.tk'.nt' -> NoCol(en,tk,en',nt'))


NoCollisionViolation = [](en,tk): EntrySet @ [] (en',tk'): EntrySet @ NoCol(en,tk,en',tk')


assert NoCollisionViolation [T= FullSystem \ {| setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror |}


--No Run Through

NonRunthroughMove =  { move.en.tk | en <- UnitID, tk <- UnitID, tk!=OFFTRACK }

assert  CHAOS(NonRunthroughMove) [T= FullSystem \ {|turnAround, setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror|}


--No Derailment Property

assert  CHAOS({|setRoute,cancelRoute,move,hangMove,pullover,switch,perror,serror|}) [T= FullSystem \ {|turnAround|}


--No Error

assert  CHAOS({|setRoute,cancelRoute,switch,derail|}) [T= FullSystem \ {|move,hangMove,pullover,turnAround|}








-------------- model end here ------------
