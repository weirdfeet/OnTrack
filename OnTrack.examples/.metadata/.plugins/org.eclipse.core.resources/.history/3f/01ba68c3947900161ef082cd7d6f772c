MACHINE Topology

/* Date: Fri Sep 09 09:55:15 BST 2016
 * Notes: supporting platform:/resource/Trackplans/default.ontrack model
 * Automatically generated by TrackScheme2CSPB tool version 0.2
 * Authors of Tool: Hoang Nga Nguyen, Philip James
 * Authors: Moller, Nguyen, Roggenbach, Schneider, Treharne
 *  Corresponding Authors: Hoang Nga Nguyen and Philip James
 */

[%
var bMachine1 = BMachine!Machine.all().first();
%]

SEES  Context

/*

signal: the signal associated with a route
homeSignal: the track where the signal is situated
homePoints: the track where the points are situated
next: the relation between tracks and possible successor tracks
staticNext: the successors of tracks which are independent of point positions
dynamicNext: the successors of tracks which are dependent on point positions and the dependency is included in the function

Note: if tracks go in different directions then homeSignal need not be injective
*/
/* egl */
CONSTANTS
    ENTRY, EXIT, TERMINAL, CROSSING,
    signal, homeSignal, homePoint,
    directedUnits, staticDirection, dynamicDirection,
    topoRoute, staticNext, topoRouteTable

PROPERTIES
    signal : ROUTE --> SIGNAL &
    homeSignal : SIGNAL >-> UNIT * (CONNECTOR*CONNECTOR) &
    homePoint : POINT --> UNIT &
    CROSSING <: UNIT &
    ran(homePoint) /\ CROSSING  = {} &
    ENTRY <: directedUnits &
    EXIT  <: directedUnits &
    TERMINAL <: UNIT &
    dom(ENTRY) /\ TERMINAL = {} &
    dom(EXIT)  /\ TERMINAL = {} &
    directedUnits : UNIT <-> CONNECTOR * CONNECTOR &
    staticNext : directedUnits +-> UNIT &
    staticNext =
    { dU |-> n | #(t,d1,d2).(dU = (t,d1) &
                            t /= n &
                            ran({d1}) = dom({d2}) &
                            dU : directedUnits &
                            (n,d2) : directedUnits) } &
    staticDirection : CONNECTOR <-> CONNECTOR &
    staticDirection = ran((UNIT - (ran(homePoint) \/ {nullUnit})) <| directedUnits) &

    dynamicDirection : POINT * POINTPOSITION <-> CONNECTOR * CONNECTOR &
    topoRouteTable : ROUTE * UNIT <-> CONNECTOR * CONNECTOR &
    topoRoute : ROUTE <-> directedUnits &
    topoRoute = { r |-> dU | #(t,d).(dU = (t,d) & d : topoRouteTable[{(r,t)}]) } &

[%
for (p in bMachine1.hasProperties)
{
	out.print( p.write() );
	if (hasMore) {out.println(" &");}
}
%]


END

[%

operation BMachine!BSet write() : String {

	var toReturn = "    " + self.name + " = {";

	for (el in self.hasSetElements)
	{
		toReturn = toReturn + el.name;

		if (hasMore) {toReturn = toReturn + ", ";}
	}

	toReturn = toReturn + "};";
	return toReturn;
}

operation BMachine!BSet writeElements() : String {

	var toReturn = "{";

	for (el in self.hasSetElements) {

		toReturn = toReturn + el.name;

		if (hasMore) {toReturn = toReturn + ",";}
	}

	toReturn = toReturn + "}";
	return toReturn;

}

operation BMachine!Property write() : String {

	var toReturn = "    " + self.name + " = {";
	var closePr = "";

	for (pe in self.hasPropElements) {

		// print domain elements
		closePr = "";
		for (de in pe.hasDomainElements) {
			toReturn = toReturn + "(" + de.name;
			if (hasMore) toReturn = toReturn + ",";
			closePr = closePr + ")";
		}
		toReturn = toReturn + closePr;

		// if range set is present
		if (pe.hasRangeSet.isDefined()) {

			// print |->
			toReturn = toReturn + " |-> ";

			// print set
			toReturn = toReturn + pe.hasRangeSet.writeElements();
		}

		// print range elements
		closePr = "";
		for (re in pe.hasRangeElements) {

			// print |->
			if (loopCount = 1) {toReturn = toReturn + " |-> ";}

			toReturn = toReturn + "(" + re.name;
			if (hasMore) {toReturn = toReturn + ",";}
			closePr = closePr + ")";
		}
		toReturn = toReturn + closePr;

		if (hasMore) {toReturn = toReturn + ", ";}
	}

	toReturn = toReturn + "}";
	return toReturn;
}

%]
