{-
 Date: Wed Sep 14 10:09:22 BST 2016
 Notes:  CSP model with 2 trains

 Generated by: Automatically produced by Version 0.1 of OnTrack tool
 Authors of Tool: Hoang Nga Nguyen, Philip James
 Authors of Model: Xu, Moller, Nguyen, Roggenbach
 Corresponding Authors: Xu, Hoang Nga Nguyen, Philip James

 Description:
 Complete CSP model of the railway interlocking

 Open in FDR3.

 -}

-- following datatypes are generated: UnitID, PointID, SignalID, RouteID
datatype UnitID = OFFTRACK | TC1 | TC2 | TC3 | TC8 | TC9 | TC4 | TC5 | TC6 | TC7 | TC10 | TC11 | TC12 | TC19 | TC13 | TC14 | TC15 | TC16 | TC17 | TC18 | C21 | C42
datatype PointID = P1 | P2 | P3 | P4 | P5 | P6
datatype SignalID = S1 | S2 | S5 | S3 | S4 | S6 | S7 | S8 | S9
datatype RouteID = RC21 | R5D | R2 | R3 | R5C | R4 | R5B | R5A | R1
-- end generating datatypes

--following sets are generated: PortID, BiDirPointTC, UniDirPointTC, BiDirLineTC, UniDirLineTC, CrossingID, BiPointConfig,
--                              BiLineConfig, CrossingConfig, EntryRoute,
PortID = { C21, C42 }
BiDirPointTC = { TC3, TC4, TC5, TC19, TC13, TC14 }
UniDirPointTC = {  }
BiDirLineTC = { TC1, TC2, TC8, TC9, TC6, TC7, TC11, TC12, TC15, TC16, TC17, TC18 }
UniDirLineTC = {  }
CrossingID = { TC10 }
BiPointConfig = { (TC3, TC4, TC9, TC2), (TC4, TC3, TC5, TC10), (TC5, TC6, TC4, TC10), (TC19, TC13, TC12, TC18), (TC13, TC19, TC14, TC10), (TC14, TC15, TC13, TC10) }
UniLineConfig = {  }
BiLineConfig = { (TC1, OFFTRACK, TC2), (TC2, TC1, TC3), (TC8, OFFTRACK, TC9), (TC9, TC8, TC3), (TC6, TC5, TC7), (TC7, TC6, C21), (TC11, OFFTRACK, TC12), (TC12, TC11, TC19), (TC15, TC14, TC16), (TC16, TC15, C42), (TC17, OFFTRACK, TC18), (TC18, TC17, TC19) }
CrossingConfig = { (TC10, (TC4, TC14), (TC5, TC13)) }
BannedDir = {  }
EntryRoute = { RC21 }
-- end generating sets

pointAt(P1) = TC3
pointAt(P2) = TC4
pointAt(P3) = TC5
pointAt(P4) = TC19
pointAt(P5) = TC13
pointAt(P6) = TC14
entryUsedBy(RC21) = (C21, TC7)
signalAt(S1) = (TC1, TC2)
signalAt(S2) = (TC8, TC9)
signalAt(S5) = (TC7, TC6)
signalAt(S3) = (TC11, TC12)
signalAt(S4) = (TC17, TC18)
signalAt(S6) = (TC1, OFFTRACK)
signalAt(S7) = (TC8, OFFTRACK)
signalAt(S8) = (TC11, OFFTRACK)
signalAt(S9) = (TC17, OFFTRACK)
routeOpenBy(S1) = ({ R1 })
routeOpenBy(S2) = ({ R2 })
routeOpenBy(S5) = ({ R5D, R5C, R5B, R5A })
routeOpenBy(S3) = ({ R3 })
routeOpenBy(S4) = ({ R4 })
routeOpenBy(S6) = ({  })
routeOpenBy(S7) = ({  })
routeOpenBy(S8) = ({  })
routeOpenBy(S9) = ({  })
routeCloseBy(S1) = ({  })
routeCloseBy(S2) = ({  })
routeCloseBy(S5) = ({ RC21 })
routeCloseBy(S3) = ({  })
routeCloseBy(S4) = ({  })
routeCloseBy(S6) = ({ R5A })
routeCloseBy(S7) = ({ R5B })
routeCloseBy(S8) = ({ R5C })
routeCloseBy(S9) = ({ R5D })
ctrlTable(R5D) = ({  }, { P3, P5, P4 }, { TC6, TC5, TC10, TC13, TC19, TC18, TC17 })
ctrlTable(R2) = ({ P1 }, { P2, P6 }, { TC9, TC3, TC4, TC10, TC14, TC15, TC16 })
ctrlTable(R3) = ({ P4, P5, P6 }, {  }, { TC12, TC19, TC13, TC14, TC15, TC16 })
ctrlTable(R5C) = ({ P4 }, { P3, P5 }, { TC6, TC5, TC10, TC13, TC19, TC12, TC11 })
ctrlTable(R4) = ({ P5, P6 }, { P4 }, { TC18, TC19, TC13, TC14, TC15, TC16 })
ctrlTable(R5B) = ({ P3, P2, P1 }, {  }, { TC6, TC5, TC4, TC3, TC9, TC8 })
ctrlTable(R5A) = ({ P3, P2 }, { P1 }, { TC6, TC5, TC4, TC3, TC2, TC1 })
ctrlTable(R1) = ({  }, { P1, P2, P6 }, { TC2, TC3, TC4, TC10, TC14, TC15, TC16 })
ctrlTable(RC21) = ({  }, {  }, { TC7 })
releaseTable(P1) = ({ (R2, TC3, TC4), (R2, TC3, TC9), (R2, TC3, TC4), (R2, TC3, TC3), (R5B, TC3, TC4), (R5B, TC3, TC9), (R5B, TC3, TC4), (R5B, TC3, TC3), (R5A, TC3, TC4), (R5A, TC3, TC3), (R5A, TC3, TC4), (R5A, TC3, TC9), (R1, TC3, TC4), (R1, TC3, TC3), (R1, TC3, TC4), (R1, TC3, TC9) })
releaseTable(P2) = ({ (R2, TC4, TC3), (R2, TC4, TC10), (R2, TC4, TC3), (R2, TC4, TC5), (R5B, TC4, TC3), (R5B, TC4, TC5), (R5B, TC4, TC3), (R5B, TC4, TC10), (R5A, TC4, TC3), (R5A, TC4, TC5), (R5A, TC4, TC3), (R5A, TC4, TC10), (R1, TC4, TC3), (R1, TC4, TC10), (R1, TC4, TC3), (R1, TC4, TC5) })
releaseTable(P3) = ({ (R5D, TC5, TC6), (R5D, TC5, TC10), (R5D, TC5, TC6), (R5D, TC5, TC4), (R5C, TC5, TC6), (R5C, TC5, TC10), (R5C, TC5, TC6), (R5C, TC5, TC4), (R5B, TC5, TC6), (R5B, TC5, TC4), (R5B, TC5, TC6), (R5B, TC5, TC10), (R5A, TC5, TC6), (R5A, TC5, TC4), (R5A, TC5, TC6), (R5A, TC5, TC10) })
releaseTable(P4) = ({ (R5D, TC19, TC13), (R5D, TC19, TC18), (R5D, TC19, TC13), (R5D, TC19, TC12), (R3, TC19, TC13), (R3, TC19, TC12), (R3, TC19, TC13), (R3, TC19, TC18), (R5C, TC19, TC13), (R5C, TC19, TC12), (R5C, TC19, TC13), (R5C, TC19, TC18), (R4, TC19, TC13), (R4, TC19, TC18), (R4, TC19, TC13), (R4, TC19, TC12) })
releaseTable(P5) = ({ (R5D, TC13, TC19), (R5D, TC13, TC13), (R5D, TC13, TC19), (R5D, TC13, TC14), (R3, TC13, TC19), (R3, TC13, TC14), (R3, TC13, TC19), (R3, TC13, TC13), (R5C, TC13, TC19), (R5C, TC13, TC13), (R5C, TC13, TC19), (R5C, TC13, TC14), (R4, TC13, TC19), (R4, TC13, TC14), (R4, TC13, TC19), (R4, TC13, TC13) })
releaseTable(P6) = ({ (R2, TC14, TC15), (R2, TC14, TC14), (R2, TC14, TC15), (R2, TC14, TC13), (R3, TC14, TC15), (R3, TC14, TC13), (R3, TC14, TC15), (R3, TC14, TC14), (R4, TC14, TC15), (R4, TC14, TC13), (R4, TC14, TC15), (R4, TC14, TC14), (R1, TC14, TC15), (R1, TC14, TC14), (R1, TC14, TC15), (R1, TC14, TC13) })

-- following functions are generated: pointAt, signalAt, routeOpenBy, routeCloseBy, entryUsedBy, ctrlTable,
--                                    releaseTable

-------------------------following are generic for all models
datatype PointST = Norm | Rvers   --***********************************

swap(Norm)=Rvers
swap(Rvers)=Norm

BiLineDir    = {(t0,t,t1), (t1,t,t0)              --***********************************
                 | (t,t0,t1) <- BiLineConfig}   --***********************************


CrossingDir  = {(t0,t,t1), (t1,t,t0), (t2,t,t3), (t3,t,t2)  --***********************************
                 | (t,(t0,t1),(t2,t3)) <- CrossingConfig}  --***********************************



-- offtrack is reached one later than in the original models of the group
BiPointDir    = {(m,t,n), (n,t,m), (m,t,r), (r,t,m),  --***********************************
                 (n,t,OFFTRACK), (r,t,OFFTRACK)       --***********************************
                 | (t,m,n,r) <- BiPointConfig}        --***********************************


ConfigDir = Union({BiPointDir, UniLineConfig, BiLineDir,CrossingDir})


OkDir = diff(ConfigDir, BannedDir)   --***********************************


pointDir(pID, Norm)=  diff({(m,t,n), (n,t,m), (r,t,OFFTRACK) | (t,m,n,r) <- BiPointConfig, t==pointAt(pID)}, BannedDir)

pointDir(pID, Rvers)= diff({(m,t,r), (r,t,m), (n,t,OFFTRACK) | (t,m,n,r) <- BiPointConfig, t==pointAt(pID)}, BannedDir)




--next(entryConnector)=exitConnector
next(n, t) = { x | x <- UnitID, member((n,t,x), OkDir)}   --***********************************


--Entry and Exit sets
EntrySet = { (n, t) | (n, t, x) <- OkDir, member(n, PortID) }

ExitSet =  { (t, x) | (n, t, x) <- OkDir, member(x, PortID) }

entrySignal(r) = { sID | sID <- SignalID, member(r,routeOpenBy(sID)) }

exitSignal(r)  = { sID | sID <- SignalID, member(r,routeCloseBy(sID)) }

clearTable(route)   = let
                        (_,_,clearTracks) = ctrlTable(route)
                      within
                        clearTracks


NormalPoints(route) =  let
      (points,_,_) = ctrlTable(route)
                      within
                        points

ReversePoints(route) =  let
      (_,points,_) = ctrlTable(route)
                      within
                        points

pointRoute(pID,st) = {r | r <- RouteID, member(pID, if st==Norm then NormalPoints(r) else ReversePoints(r))}

pointAllRoute(pID) = {r | r <- RouteID, member(pID, union(ReversePoints(r),NormalPoints(r)))}

pointInRoute(pID)  = {r | r <- pointAllRoute(pID), member(pointAt(pID), clearTable(r))}
-- route in which the point is non-flank protection -----

ReleaseMove(pID,rID)     = {move.cp.np | (r,cp,np) <- releaseTable(pID), r==rID}
PointReleaseMove(pID) = {move.cp.np | (r,cp,np) <- releaseTable(pID)}
--PointReleaseMove(pID,st) = {move.cp.np | rID <- pointRoute(pID,st), (r,cp,np) <- releaseTable(pID), r==rID}

----------------------------------------------------------------------------

TrainID = {1,2}

--Types/Channels
channel move: UnitID.UnitID --Train Movement
channel setRoute: RouteID --Route being Set
channel cancelRoute: RouteID -- Route being cancelled
channel switch: PointID -- Point direction being changed
channel hangMove: UnitID.UnitID  -- Hang Signal
channel turnAround: UnitID.UnitID.UnitID  -- Train change direction
channel pullover: UnitID.UnitID  -- Train pulls over
channel derail : PointID -- demonstrates a derailment has occured
channel perror : PointID  -- demonstrates a point error has occured
channel serror : SignalID -- demonstrates a signal error has occured


-- alphabet of train: i.e. {|setRoute,cancelRoute,move,hangMove,pullover,turnAround|}

TrainBehave(id,en,tk) = (move.en.tk -> if empty(next(en,tk))
                                            then [] (en1,tk1): EntrySet @ TrainBehave(id,en1,tk1)
                                         -- then TrainStop(id,OFFTRACK)
                                            else [] nt: next(en,tk) @ TrainBehave(id,tk,nt))
        		[]
        		([] r: RouteID @ not(member(en,clearTable(r))) & setRoute.r -> TrainBehave(id,en,tk))
        		[]
        		([] r: RouteID @ if empty(entrySignal(r)) then cancelRoute.r -> TrainBehave(id,en,tk)
                                         else [] sID : entrySignal(r) @ (en,tk)!=signalAt(sID) &
                                                       cancelRoute.r -> TrainBehave(id,en,tk))
                         --Required to check a train is not about to enter a route it will cancel.
        		[]
        		([] sID : SignalID @ (en,tk)==signalAt(sID) & hangMove.en.tk -> STOP
                                                                                     --TrainStop(id,tk)
                        )
        		[]
        		([] sID : SignalID @ (en,tk)==signalAt(sID) & pullover.en.tk ->
                               ([] nt: next(tk,en) @ [] rsID: SignalID @ signalAt(rsID)==(en,nt) &
                                                             turnAround.en.tk.nt -> TrainBehave(id,en,nt))
                        )


TrainStop(id,en)      = ([] r: RouteID @ not(member(en,clearTable(r))) & setRoute.r -> TrainStop(id,en))
        		[]
        		([] r: RouteID @ cancelRoute.r -> TrainStop(id,en))


Trains = [|{|setRoute,cancelRoute|}|] id: TrainID @ ([] (en,tk): EntrySet @ TrainBehave(id,en,tk))

EntryGuard = [] r: EntryRoute @ (setRoute.r -> let (en,tk)=entryUsedBy(r) within
                                   ( move.en.tk -> EntryGuard [] cancelRoute.r -> EntryGuard ) )

EntryAlphMove  = { move.en.tk | (en,tk) <- EntrySet }
EntryAlphRoute = {setRoute.r,cancelRoute.r | r <- EntryRoute}

GuardedTrains =  Trains [|union(EntryAlphMove, EntryAlphRoute)|] EntryGuard


datatype Aspect = Red | Green | Lock


routeRversGuardBy(sID)=
    let (en,tk) = signalAt(sID) within
       diff({r | r <- RouteID, member(en,clearTable(r))}, union(routeOpenBy(sID),routeCloseBy(sID)))

SignalBehave(sID, st)=
    let (en,tk) = signalAt(sID) within
         ([] r: routeOpenBy(sID) @ st==Green & cancelRoute.r -> SignalBehave(sID,Red))
        []
         ([] r: routeOpenBy(sID) @ st==Red  & setRoute.r -> SignalBehave(sID,Green))
        []
         (st==Red & hangMove.en.tk -> SignalBehave(sID,st))
        []
         (st==Red & pullover.en.tk -> SignalBehave(sID,st))
        []
         (st == Green & move.en.tk -> SignalBehave(sID,Red))
        []   ----------begin{receptive}
         (st != Lock & move.tk.en -> serror.sID -> STOP)
        []
         (st == Lock & move.tk.en -> SignalBehave(sID,Red))
        []
         ([] r: routeRversGuardBy(sID) @ st==Lock & cancelRoute.r -> SignalBehave(sID,Red))
        []
         ([] r: routeRversGuardBy(sID) @ st!=Lock & cancelRoute.r -> serror.sID -> STOP)
        []
         ([] r: routeCloseBy(sID)  @ cancelRoute.r -> SignalBehave(sID,st))
        []   ----------end{receptive}
         ([] r: routeRversGuardBy(sID) @ st==Red & setRoute.r -> SignalBehave(sID,Lock))
        []
         ([] r: routeCloseBy(sID)  @ st!=Lock & setRoute.r -> SignalBehave(sID,st))



sigAlphRoute(sID) =  { cancelRoute.r, setRoute.r |
       r <- Union({routeOpenBy(sID),routeRversGuardBy(sID),routeCloseBy(sID)}) }

sigAlphMove(sID) = let (en,tk) = signalAt(sID) within { move.en.tk, move.tk.en}

sigAlphOther(sID) =  let (en,tk) = signalAt(sID) within {hangMove.en.tk, pullover.en.tk, serror.sID}

Signals = || sID: SignalID @ [ Union({sigAlphRoute(sID), sigAlphMove(sID), sigAlphOther(sID)})] SignalBehave(sID, Red)


sigSysAlphMove  = Union({sigAlphMove(sID) | sID <- SignalID})

sigSysAlphRoute = Union({sigAlphRoute(sID) | sID <- SignalID}) -- == {| setroute, cancelroute |}


unlock(mv,pID)={r | r <- RouteID, member(mv,ReleaseMove(pID,r))}

PointExitMove(pID) = { move.tk.ex | (en, tk, ex) <- OkDir, pointAt(pID)==tk }              --***********************************


PointEntry(pID,st)=
        (switch.pID -> PointEntry(pID,swap(st)))
     [] ([] (en,tk,ex): pointDir(pID, st) @
           move.en.tk ->(let ActivePoint =
                             (ex==OFFTRACK & move.tk.ex -> STOP)
                          [] (ex!=OFFTRACK & move.tk.ex -> PointEntry(pID,st))
                          [] (switch.pID -> derail.pID -> STOP)
                          [] ([] (en',tk',ex'): pointDir(pID, st) @ move.en'.tk' -> STOP)
                          [] ([] r : pointRoute(pID,st) @ setRoute.r -> ActivePoint)
                          [] ([] r : pointRoute(pID,st) @ cancelRoute.r -> ActivePoint)
                         within ActivePoint
                        )
        )
     [] ([] r : pointRoute(pID,st) @ setRoute.r -> PointEntry(pID,st))
     [] ([] r : pointRoute(pID,st) @ cancelRoute.r -> PointEntry(pID,st))


pntEnAlphMove(pID) = { move.en.tk, move.tk.ex | st <- PointST, (en,tk,ex) <- pointDir(pID, st) }

pntAlphRoute(pID) = { setRoute.r, cancelRoute.r | r <- pointAllRoute(pID) }


PointExit(pID,toCancel,toRelease)=
      (toCancel == {} and toRelease == {} & switch.pID -> PointExit(pID,{},{}))
------begin{receptive}
   [] ([]r: pointAllRoute(pID)@ setRoute.r -> if member(r, pointInRoute(pID))
                                              then if toCancel=={}
                                                   then PointExit(pID, {r}, toRelease)
                                                   else perror.pID -> STOP
                                              else if member(r, toRelease)
                                                   then perror.pID -> STOP
                                                   else PointExit(pID, toCancel, union(toRelease,{r})))
   [] ([]r: pointAllRoute(pID)@ cancelRoute.r -> if member(r,union(toCancel,toRelease))
                                                 then PointExit(pID, diff(toCancel,{r}), diff(toRelease,{r}))
                                                 else perror.pID -> STOP)
   [] ([] mv : PointExitMove(pID) @ mv ->
          let unlk= inter(union(toCancel,toRelease),unlock(mv,pID)) within
            if empty(toCancel) then perror.pID -> STOP
            else if empty(unlk) then PointExit(pID, toCancel, toRelease)
                 else if unlk==toCancel then PointExit(pID, {}, toRelease)
                      else perror.pID -> STOP)
   [] ([] mv : diff(PointReleaseMove(pID),PointExitMove(pID)) @ mv ->
          let unlk= inter(union(toCancel,toRelease),unlock(mv,pID)) within
            if card(unlk)<=1
            then PointExit(pID, diff(toCancel,unlk), diff(toRelease,unlk))
            else perror.pID -> STOP)
------end{receptive}

pntExAlphMove(pID) = union(PointReleaseMove(pID), PointExitMove(pID))


PointBehave(pID) =  PointEntry(pID, Norm) [ Union({pntAlphRoute(pID), pntEnAlphMove(pID), {switch.pID, derail.pID}})
                                     || Union({pntAlphRoute(pID), pntExAlphMove(pID), {switch.pID,perror.pID}}) ] PointExit(pID, {}, {})

pntAlphMove(pID) = union(pntEnAlphMove(pID), pntExAlphMove(pID))


Points =  || pID:PointID @ [ Union({pntAlphRoute(pID), pntAlphMove(pID), {switch.pID, derail.pID, perror.pID}}) ] PointBehave(pID)

pntSysAlphMove  = Union({pntAlphMove(pID) | pID <- PointID})

pntSysAlphRoute = Union({pntAlphRoute(pID) | pID <- PointID})

-- and {| switch, derail, perror |}



TrackSystem = Points [| union(pntSysAlphRoute,inter(sigSysAlphMove,pntSysAlphMove)) |] Signals

trackSysAlphMove = union(sigSysAlphMove,pntSysAlphMove)

trackSysAlphRoute = union(sigSysAlphRoute, pntSysAlphRoute)


FullSystem = TrackSystem [| Union({trackSysAlphMove,trackSysAlphRoute, {|hangMove,pullover|}}) |] GuardedTrains








--No Collision
NoCol(en,tk,en',tk')= (tk != en' & move.en.tk -> if empty(next(en,tk))
                                                   then [](en1,tk1): EntrySet @ NoCol(en1,tk1,en',tk')
                                                   else [] nt: next(en,tk) @ NoCol(tk,nt,en',tk'))
                     [] (tk' != en & move.en'.tk' ->
                                                     if empty(next(en',tk'))
                                                     then [](en2,tk2): EntrySet @ NoCol(en,tk,en2,tk2)
                                                     else []nt': next(en',tk') @ NoCol(en,tk,tk',nt'))
                     [] ([] nt: next(tk,en) @ turnAround.en.tk.nt -> NoCol(en,nt,en',tk'))
                     [] ([] nt': next(tk',en') @ turnAround.en'.tk'.nt' -> NoCol(en,tk,en',nt'))


NoCollisionViolation = [](en,tk): EntrySet @ [] (en',tk'): EntrySet @ NoCol(en,tk,en',tk')


assert NoCollisionViolation [T= FullSystem \ {| setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror |}


--No Run Through

NonRunthroughMove =  { move.en.tk | en <- UnitID, tk <- UnitID, tk!=OFFTRACK }

assert  CHAOS(NonRunthroughMove) [T= FullSystem \ {|turnAround, setRoute,cancelRoute,switch,hangMove,pullover,derail,perror,serror|}


--No Derailment Property

assert  CHAOS({|setRoute,cancelRoute,move,hangMove,pullover,switch,perror,serror|}) [T= FullSystem \ {|turnAround|}


--No Error

assert  CHAOS({|setRoute,cancelRoute,switch,derail|}) [T= FullSystem \ {|move,hangMove,pullover,turnAround|}








-------------- model end here ------------
